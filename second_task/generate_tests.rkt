#lang scheme/base

(define (dedupe e)
  (if (null? e) '()
      (cons 
        (car e) 
        (dedupe (filter (lambda (x) (not (equal? x (car e)))) (cdr e)))
      )
  )
)

(define (checker clr-g1 clr-g2)
  (define (check-edges label1 label2)
    (if 
      (equal? 
        (map (lambda(x) (car x)) (filter (lambda(x) (equal? label1 (cadr x))) clr-g1))
        (map (lambda(x) (car x)) (filter (lambda(x) (equal? label2 (cadr x))) clr-g2)) 
      )
      #t
      #f
    )
  )
  (andmap check-edges (dedupe (map (lambda(x) (cadr x)) clr-g1)) (dedupe (map (lambda(x) (cadr x)) clr-g2)))
)

(define (combinations-2 list1 list2)
  (define (loop l1 l2 res)
    (cond
      ((and (= (length l1) 1) (= (length l2) 0))  res)
      ((= (length l2) 0) (loop (cdr l1) list2 res))
      (else (loop l1 (cdr l2) (cons (list (car l1) (car l2)) res)))
    )
  )
  (loop list1 list2 '())
)

(define (range-list start end)
  (define (loop i res)
    (if (= i start)
      (cons i res)
      (loop (- i 1) (cons i res))
    )
  )
  (loop (- end 1) '())
)

(define (gen-chain num)
  (define (loop i res)
    (if (= i 0)
      res
      (loop (- i 1) (cons (list (- i 1)  i) res))
    )
  )
  (loop num '())
)

(define (gen-cycle num)
  (define (loop i res)
    (if (= i 0)
      res
      (loop (- i 1) (cons (list (- i 1)  i) res))
    )
  )
  (loop (- num 1) (list (list (- num 1) 0)))
)

(define (gen-complete num)
  (define (loop i j res)
    (cond
      ((and (= i 1) (= j 0)) (reverse (cons (list 1 0) res)))
      ((= j 0) (loop (- i 1) (- i 2) (cons (list i 0) res)))
      (else (loop i (- j 1) (cons (list i j) res)))
    )
  )
  (loop num (- num 1) '())
)

(define (gen-bipartite first-group second-group)
  (combinations-2 (range-list 0 first-group) (range-list first-group (+ first-group second-group)))
)

(define (print-chains num)
  (define (loop i)
    (if (= i num)
      (void)
      (begin
        (printf "~a ~a ~a~n" (gen-chain i) #t 2)
        (printf "~a ~a ~a~n" (gen-chain i) #f 1)
        (loop (+ i 1))
      )
    )
  )
  (loop 1)
)

(define (print-cycle num)
  (define (loop i)
    (if (= i num)
      (void)
      (begin
        (printf "~a ~a ~a~n" (gen-cycle i) #t (+ 2 (modulo i 2)))
        (printf "~a ~a ~a~n" (gen-cycle i) #f 1)
        (loop (+ i 1))
      )
    )
  )
  (loop 3)
)

(define (print-complete num)
  (define (loop i)
    (if (= i num)
      (void)
      (begin
        (printf "~a ~a ~a~n" (gen-complete i) #t (+ ( - i 1) (modulo i 2)))
        (printf "~a ~a ~a~n" (gen-complete i) #f (- i 2))
        (loop (+ i 1))
      )
    )
  )
  (loop 3)
)

(define (print-bipartite num)
  (define (loop i)
    (if (= i num)
      (void)
      (begin
        (printf "~a ~a ~a~n" (gen-bipartite i (truncate (/ i 2))) #t i)
        (printf "~a ~a ~a~n" (gen-bipartite i (truncate (/ i 2))) #f (- i 2))
        (loop (+ i 1))
      )
    )
  )
  (loop 4)
)

;(printf "~a~n" (gen-chain 5))
;(printf "~a~n" (gen-cycle 5))
;(printf "~a~n" (gen-complete 5))
;(printf "~a" (gen-bipartite 3 2))
(print-chains 10)
(print-cycle 10)
(print-complete 10)
(print-bipartite 6)
(checker '(((0 1) 1) ((1 2) 2) ((2 3) 1)) '(((0 1) 3) ((1 2) 4) ((2 3) 3)))

#lang scheme/base
(define (sum-of-natural-dividers num)
  (define (loop i threshold res)
    (if (> i threshold)
      res
      (if (= (modulo num i) 0)
          (if (= i (/ num i))
            (loop (+ 1 i) threshold (+ res i))
            (loop (+ 1 i) threshold (+ res i (/ num i)))
          )
          (loop (+ 1 i) threshold res)
      )
    )
  )
  (loop 1 (sqrt num) 0)
)
(define (is-abundant? n)
  (if (> (sum-of-natural-dividers n) (* 2 n))
    #t
    #f
  )
)
(define (abundant n)
  (define (loop i already-found)
    (if (is-abundant? i)
      (if (= (+ 1 already-found) n)
        i
        (loop (+ 1 i) (+ 1 already-found))
      )
      (loop (+ 1 i) already-found)
    )
  )
  (loop 1 0)
)
(abundant 9)

(define abund-table (make-hash))
(define (memo-abundant n)
  (define (loop i already-found) 
    (if (is-abundant? i)
      (if (= (+ 1 already-found) n)
        (begin
          (hash-set! abund-table (+ 1 already-found) i)
          i
        )
        (loop (+ 1 i) (+ 1 already-found))
      )
      (loop (+ 1 i) already-found)
    )
  )
  (if (= n 0) 1
  (let ((res (hash-ref abund-table n #f)))
    (if res res
      (loop (+ 1 (memo-abundant (- n 1))) (- n 1))
    )
  )
  )
)
;(memo-abundant 9)
;(memo-abundant 5)

(define-syntax swap2
  (syntax-rules ()
    ((swap2 a b)
     (begin
       (define c b)
       (set! b a)
       (set! a c)
     )
    )
  )
)
(define a 2)
(define b 3)
(print (list a b))
(swap2 a b)
(print (list a b))

(define-syntax rot-right
  (syntax-rules ()
    ((rot-right a b c)
     (begin
       (define d c)
       (set! c b)
       (set! b a)
       (set! a d)
     )
    )
  )
)

(define a1 2)
(define b1 3)
(define c1 4)
(print (list a1 b1 c1))
(rot-right a1 b1 c1)
(print (list a1 b1 c1))
(define (check a) (cadr a))
(define  kek '(a b c))
(check kek)
(print kek)